---
title: 《高性能MySQL》笔记（未完待续）
categories:
  - 数据库
  - MySQL
tags: 
  - MySQL 
  - 数据库
---

## 一、MySQL架构
### 1. 逻辑架构
![](1528164050299.png)
存储引擎只负责数据的存储和提取。
### 2. 并发控制

读写锁
- 读锁是共享的，互相不堵塞。
- 写锁是排他的，会堵塞其他读锁和写锁。

锁粒度
- 表锁
- 行级锁

### 3. 事务
**ACID**：原子性、一致性、隔离性、持久性。
**隔离级别**：未提交读，提交读（不可重复读），**可重复读（InnoDB默认）**，可串行化。
**脏读**：其他事务能读取到未提交事务的数据。
**不可重复读**：一个事务从开始到提交之前，所做的任何修改对其他事务都是不可变的。
**幻读**：当某个事务在读取某个范围的记录时，另一个事务又在该范围插入了新的记录，当之前的事务再读取该范围的记录时，会产生幻行。InnoDB通过MVVC解决了此问题。
**死锁**
**事务日志**
![](1528165184212.png)
![](1528164708185.png)
![](1528165257001.png)
![](1528165284743.png)

### 4. 存储引擎：InnoDB
InnoDB采用MVVC来支持高并发，默认隔离级别为可重复读，并通过锁间隙策略防止幻读的出现。
InnoDB是基于聚簇索引建立的，所以对主键查询有很高的性能。
![](1528165568341.png)

## 二、基准测试

## 三、服务器性能剖析

## 四、Schema和数据类型优化
### 基本原则
1. 更小的通常更好
2. 简单就好
3. 尽量避免NULL
![](1528166010362.png)
![](1528166020915.png)
### 数据列行
#### 整数
![](1528166180732.png)
#### 实数
![](1528166285644.png)
#### 字符串
![](1528166497095.png)
![](1528166503129.png)
![](1528166577789.png)
![](1528166760090.png)
#### 日期和时间类型
![](1528166874106.png)
![](1528166883899.png)
![](1528166935101.png)
![](1528166966341.png)
![](1528167072144.png)
#### 主键
![](1528167259811.png)
![](1528167289290.png)
### 范式和反范式
![](1528167581622.png)
![](1528167611199.png)
![](1528167512105.png)
### 缓存表和汇总表
![](1528167732956.png)
![](1528168400328.png)
### 加快ALERT TABLE

## 五、创建高性能索引
![](1528182528196.png)
![](1528182592069.png)
![](1528183018595.png)
![](1528183338058.png)
![](1528183797092.png)
![](1528183383361.png)
![](1528183412753.png)
### 高性能索引策略
![](1528184158440.png)

1. 独立的列，不能出现如下语句：

```
select * from user where user.id + 1 =5
```
2. 前缀索引和索引选择性
3. 多列索引
![](1528183901629.png)
4. 选择合适的索引列顺序
适用于B-Tree
![](1528184350233.png)
![](1528184515192.png)
5. 聚簇索引
![](1528184714356.png)
![](1528184828359.png)
![](1528184863210.png)
6. 覆盖索引
![](1528185061290.png)
![](1528185165896.png)
7. 使用索引扫描来做排序
![](1528185267789.png)
![](1528185299261.png)
![](1528185358537.png)
8. 压缩（前缀压缩）索引
9. 冗余和重复索引
![](1528185507814.png)
![](1528185554162.png)
10. 未使用的索引
11. 索引和锁
![](1528185648882.png)

## 六、查询性能优化
### 慢查询基础：优化数据访问
1. 是否请求了不需要的数据
2. 是否在扫描额外的记录
### 重构查询的方式
1. 一个复杂查询还是多个简单查询
2. 切分查询
3. 分解关联查询
![](1528186698447.png)
### 查询执行的基础
![](1528186874492.png)
![](1528186942921.png)
### 查询优化器的局限
### 查询优化器的提示
### 优化特定类型的查询

## 阅读
1. [我必须得告诉大家的 MySQL 优化原理](https://juejin.im/entry/590427815c497d005832dab9)
2. [理解索引：MySQL执行计划详细介绍](https://juejin.im/post/5b1243eff265da6e0b6ff277)
